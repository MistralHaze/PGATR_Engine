#version 430
#define SIZE_X 32
#define SIZE_Y 1

layout( std140, binding = 0 ) buffer Pos {
   vec4 Positions[ ];
};

layout(binding = 1) uniform UniformBufferObject {
    int stage;
    int subStage;
} ubo;


layout (local_size_x = SIZE_X, local_size_y = SIZE_Y) in;


//Algoritmo adaptado de OpenCL Parallel Programming Development Cookbook de Raymond Tay

//Indice de la particula a integrar
uint gid = gl_GlobalInvocationID.x;

void main()
{
	bool sortIncreasing = true;
	uint threadId = gid;

	// Determine where to conduct the bitonic split
	// by locating the middle-point of this 1D array
	// Recuerda 1 << a = 2^a
	uint distanceBetweenPairs = 1 << (ubo.stage - ubo.subStage);
	uint blockWidth = 2 * distanceBetweenPairs;

	// Determine the left and right indexes to the data
	uint leftIndex = (threadId % distanceBetweenPairs) + (threadId / distanceBetweenPairs) * blockWidth;
	uint rightIndex = leftIndex + distanceBetweenPairs;

	float leftElement =  ( Positions[leftIndex]).z;
	float rightElement = ( Positions[rightIndex]).z;

	 // Threads are divided into blocks of size 2^sameDirectionBlockWidth
	 // and its used to build bitonic subsequences s.t the sorting is
	 // monotically increasing on the left and decreasing on the right
	 uint sameDirectionBlockWidth = 1 << ubo.stage;

	 //Cambia la direccion
	 if((threadId/sameDirectionBlockWidth) % 2 == 1)
		sortIncreasing = !sortIncreasing;

	 vec4 greaterPos;
	 vec4 lesserPos;	
	 
	 vec4 greaterVel;
	 vec4 lesserVel;
	 
	 vec4 greaterCol;
	 vec4 lesserCol;

	 // perform pairwise comparison between two elements and depending
	 // whether its to build the bitonic that is monotically increasing
	 // and decreasing.
	 if(leftElement > rightElement) 
	 {
		 greaterPos = Positions[leftIndex];

		 lesserPos = Positions[rightIndex];
	 }
	 else
	 {
		 greaterPos = Positions[rightIndex];

		 lesserPos = Positions[leftIndex];
	 }

	 if(sortIncreasing)
	 {
		 Positions[leftIndex] = lesserPos;

		 Positions[rightIndex] = greaterPos;	 
	 } 
	 else 
	 {
		 Positions[leftIndex] = greaterPos;

		 Positions[rightIndex] = lesserPos;
	 }

}
